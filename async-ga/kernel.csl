// Struct containing parameters for memcpy layout
param peId: i16;
param x: i16;
param y: i16;
param memcpy_params: comptime_struct;

// memcpy module provides infrastructure for copying data
// and launching functions from the host
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

// module imports
const math = @import_module("<math>");
const random = @import_module("<random>");

// global output variables
var cycleCounter = @zeros([1]u16);
var ptr_cycleCounter : [*]u16 = &cycleCounter;

var recvCounter_N = @zeros([1]u16);
var ptr_recvCounter_N : [*]u16 = &recvCounter_N;
var recvCounter_S = @zeros([1]u16);
var ptr_recvCounter_S : [*]u16 = &recvCounter_S;

var sendCounter_N = @zeros([1]u16);
var ptr_sendCounter_N : [*]u16 = &sendCounter_N;
var sendCounter_S = @zeros([1]u16);
var ptr_sendCounter_S : [*]u16 = &sendCounter_S;

var genome = @zeros([1]f32);
var ptr_genome : [*]f32 = &genome;

var whoami = @zeros([1]i16);
var ptr_whoami : [*]i16 = &whoami;

var whereami_x = @zeros([1]i16);
var ptr_whereami_x : [*]i16 = &whereami_x;

var whereami_y = @zeros([1]i16);
var ptr_whereami_y : [*]i16 = &whereami_y;

const popSize: u16 = 64;
var population = @zeros([popSize]f32);
const populationDsd = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{1} -> population[i]
});
var ptr_population: [*]f32 = &population;

// task IDs ===================================================================
///////////////////////////////////////////////////////////////////////////////
const sendTaskID_N: local_task_id = @get_local_task_id(10);
const sendTaskID_S: local_task_id = @get_local_task_id(11);

const sendFinalizeTaskID_N: local_task_id = @get_local_task_id(14);
const sendFinalizeTaskID_S: local_task_id = @get_local_task_id(15);

const recvTaskID_N: local_task_id = @get_local_task_id(18);
const recvTaskID_S: local_task_id = @get_local_task_id(19);

const recvFinalizeTaskID_N: local_task_id = @get_local_task_id(0);
const recvFinalizeTaskID_S: local_task_id = @get_local_task_id(1);

const sendColor_N: color = @get_color(2);
const recvColor_S: color = @get_color(3);

const recvColor_N: color = @get_color(4);
const sendColor_S: color = @get_color(5);

const cycleColor: color = @get_color(9);
const cycleTaskID: data_task_id = @get_data_task_id(cycleColor);

const mainTaskID: local_task_id = @get_local_task_id(25);
const endTaskIDID: local_task_id = @get_local_task_id(26);

///////////////////////////////////////////////////////////////////////////////
// ============================================================================
// send tasks
// ============================================================================
///////////////////////////////////////////////////////////////////////////////
const sendBufSize: u16 = popSize;
const sendNum: u16 = 8;

// send NORTH =================================================================
var sendBuf_N = @zeros([sendBufSize]f32); var sendFlag_N: u8 = 1;
const sendBufDsd_N = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_N[i]
});

task sendFinalizeTask_N() void { sendFlag_N = 1; sendCounter_N[0] += 1; }

const sendDsd_N = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_N,
  .output_queue = @get_output_queue(2)
});
task sendTask_N() void {
  @fmovs(
    sendDsd_N, sendBufDsd_N,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_N,
      .priority = .{ .high = true }
    }
  );
  sendCounter_N[0] += 1;
}

// send SOUTH =================================================================
var sendBuf_S = @zeros([sendBufSize]f32); var sendFlag_S: u8 = 1;
const sendBufDsd_S = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_S[i]
});

task sendFinalizeTask_S() void { sendFlag_S = 1; sendCounter_S[0] += 1; }

const sendDsd_S = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_S,
  .output_queue = @get_output_queue(1)
});
task sendTask_S() void {
  @fmovs(
    sendDsd_S, sendBufDsd_S,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_S,
      .priority = .{ .high = true }
    }
  );
  sendCounter_S[0] += 1;
}

// recv task ==================================================================
///////////////////////////////////////////////////////////////////////////////

const recvBufSize: u16 = 4;

// recv NORTH =================================================================
var recvBuf_N = @zeros([recvBufSize]f32); var recvFlag_N: u8 = 0;
const recvBufDsd_N = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_N[i]
});

task recvFinalizeTask_N() void { recvFlag_N = 1; recvCounter_N[0] += 1; }

const recvDsd_N = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_N,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(4)
});
task recvTask_N() void {
  @fmovs(
    recvBufDsd_N, recvDsd_N,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_N,
      .priority = .{ .high = true }
    },
  );
  recvCounter_N[0] += 1;
}

// recv SOUTH =================================================================
var recvBuf_S = @zeros([recvBufSize]f32); var recvFlag_S: u8 = 0;
const recvBufDsd_S = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_S[i]
});

task recvFinalizeTask_S() void { recvFlag_S = 1; recvCounter_S[0] += 1; }

const recvDsd_S = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_S,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(5)
});
task recvTask_S() void {
  @fmovs(
    recvBufDsd_S, recvDsd_S,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_S,
      .priority = .{ .high = true }
    },
  );
  recvCounter_S[0] += 1;
}

// cycle task =================================================================
///////////////////////////////////////////////////////////////////////////////

const cycleDsd = @get_dsd(fabout_dsd, .{
    .extent = 1,
    .fabric_color = cycleColor,
  }
);

fn integrate(genome_: f32) void {
    const target = @as(u16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= target and target < popSize);  // makes slow
    population[target] = math.max(population[target], genome_);
}

// self-activate with incrementing values
// until threshold reached
task cycleTask(data: u16) void {

  // handle send flags
  if (@as(bool, sendFlag_N)) {
    @fmovs(sendBufDsd_N, populationDsd);
    sendFlag_N = 0;
    // bottom half of PE array (assuming 2x2)
    if (y == 1) @activate(sendTaskID_N);
  }
  if (@as(bool, sendFlag_S)) {
    @fmovs(sendBufDsd_S, populationDsd);
    sendFlag_S = 0;
    // top half of PE array (assuming 2x2)
    if (y == 0) @activate(sendTaskID_S);
  }

  // handle recv flags
  if (@as(bool, recvFlag_N)) {
    @map(integrate, recvBufDsd_N);
    recvFlag_N = 0;
    @activate(recvTaskID_N);
  }
  if (@as(bool, recvFlag_S)) {
    @map(integrate, recvBufDsd_S);
    recvFlag_S = 0;
    @activate(recvTaskID_S);
  }

  // generational turnover
  for (@range(u16, 32)) |tournament| {
    const parent1 = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= parent1 and parent1 < popSize);  // makes slow
    const parent2 = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= parent2 and parent2 < popSize); // makes slow

    const offspring1: f32 = population[parent1] + random.random_normal_f32();
    const offspring2: f32 = population[parent2] + random.random_normal_f32();

    const target = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= target and target < popSize); // makes slow
    population[target] = math.max(offspring1, offspring2);
  }
  genome[0] = population[0];

  if (data < 20) {
    const next: u16 = data + 1;
    @mov16(cycleDsd, next);
  } else {
    sys_mod.unblock_cmd_stream();
  }
  cycleCounter[0] = data;
}

// main task ==================================================================
///////////////////////////////////////////////////////////////////////////////

task mainTask() void {
  whoami[0] = peId;
  whereami_x[0] = x;
  whereami_y[0] = y;
  random.set_global_prng_seed(peId);
  @activate(recvTaskID_N);
  @activate(recvTaskID_S);
  @mov16(cycleDsd, 0);
}

fn dolaunch() void { @activate(mainTaskID); } // launched by RPC

// bind tasks =================================================================
///////////////////////////////////////////////////////////////////////////////
comptime {
  @bind_local_task(sendTask_N, sendTaskID_N);
  @bind_local_task(sendTask_S, sendTaskID_S);
  @bind_local_task(sendFinalizeTask_N, sendFinalizeTaskID_N);
  @bind_local_task(sendFinalizeTask_S, sendFinalizeTaskID_S);
  @bind_local_task(recvTask_N, recvTaskID_N);
  @bind_local_task(recvTask_S, recvTaskID_S);
  @bind_local_task(recvFinalizeTask_N, recvFinalizeTaskID_N);
  @bind_local_task(recvFinalizeTask_S, recvFinalizeTaskID_S);
  @bind_data_task(cycleTask, cycleTaskID);
  @bind_local_task(mainTask, mainTaskID);
}

// finalize ===================================================================
///////////////////////////////////////////////////////////////////////////////
comptime {
  @set_local_color_config(
    cycleColor,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ RAMP } } },
  );

  @set_local_color_config(
    sendColor_N,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ NORTH }, .color_swap_y = true } },
  );
  @set_local_color_config(
    sendColor_S,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ SOUTH }, .color_swap_y = true } },
  );
  @set_local_color_config(
    recvColor_N,
    .{ .routes = .{ .rx = .{ NORTH }, .tx = .{ RAMP }, .color_swap_y = true } },
  );
  @set_local_color_config(
    recvColor_S,
    .{ .routes = .{ .rx = .{ SOUTH }, .tx = .{ RAMP }, .color_swap_y = true } },
  );


  @export_symbol(ptr_cycleCounter, "cycleCounter");
  @export_symbol(ptr_recvCounter_N, "recvCounter_N");
  @export_symbol(ptr_recvCounter_S, "recvCounter_S");
  @export_symbol(ptr_sendCounter_N, "sendCounter_N");
  @export_symbol(ptr_sendCounter_S, "sendCounter_S");
  @export_symbol(ptr_genome, "genome");
  @export_symbol(ptr_population, "population");
  @export_symbol(ptr_whoami, "whoami");
  @export_symbol(ptr_whereami_x, "whereami_x");
  @export_symbol(ptr_whereami_y, "whereami_y");
  @export_symbol(dolaunch);

  @rpc(@get_data_task_id(sys_mod.LAUNCH)); // direct remote procedure calls
}
