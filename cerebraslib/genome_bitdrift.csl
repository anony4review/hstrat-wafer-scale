// memory layout ===============================================================
// byte 0 FITNESS (f16, 2 bytes)
// byte 1
// byte 2 BITFIELD (10 bytes)
// byte 3
// byte 4
// byte 5
// byte 6
// byte 7
// byte 8
// byte 9
// byte 10
// byte 11
// TOTAL: 3 words -> 12 bytes


// module imports =============================================================
const random = @import_module("<random>");

const bitmanip = @import_module("cerebraslib/bitmanip.csl");
const opscalar = @import_module("cerebraslib/opscalar.csl");

// module params ==============================================================
const genomeWords: u16 = 3;
const genome_t = [genomeWords]u32;
const genomePtr_t = [*]u32;

// module functions ===========================================================
fn apply_mutation(genome: genomePtr_t) void {
    // mutate fitness value
    const fitness = calc_fitness(genome);
    const mutated = fitness + @as(f16, random.random_normal_f32());
    @ptrcast(*f16, genome).* = mutated;

    // elapse generation in bitfield
    const offset_bits: u16 = 2 * 8;
    const target_bit = opscalar.unif16(10 * 8) + offset_bits;
    bitmanip.flip_nth_bit(@ptrcast([*]u8, genome), target_bit);
}

fn calc_fitness(genome: genomePtr_t) f16 { return @ptrcast(*f16, genome).*; }

fn initialize(genome: genomePtr_t) void {
    bitmanip.randomize(@ptrcast([*]u16, genome), genomeWords * 2);
    @ptrcast(*f16, genome).* = 0.0;
}
