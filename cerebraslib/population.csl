// module params ==============================================================
param popSize: u16;
param fitFun: fn([*]u32) f16;
param mutFun: fn([*]u32) void;
param genomeWords: u16;
param tournamentSize: u16;

// module imports =============================================================
const math = @import_module("<math>");

const dsd = @import_module("cerebraslib/dsd.csl");
const opdsd = @import_module("cerebraslib/opdsd.csl");
const opscalar = @import_module("cerebraslib/opscalar.csl");

// global state ===============================================================
const bufSize = popSize * genomeWords;

var buffer = @zeros([bufSize]u32);
const bufferDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{bufSize} -> buffer[i],
});
const genomeDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{popSize} -> buffer[i * @as(i16, genomeWords)],
});

var swap = @zeros([bufSize]u32);
const swapDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{bufSize} -> swap[i],
});
var fitBuf = @zeros([popSize]f16);
const fitBufDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{popSize} -> fitBuf[i],
});
var indexBuf = @zeros([popSize]u16);
const indexBufDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{popSize} -> indexBuf[i],
});

// module functions ===========================================================
fn calc_fitness(i: u16) f16 { return fitFun(get_genome(i)); }

fn do_mutation(i: u16) void { mutFun(get_genome(i)); }

fn eval_fitnesses() void {
    opdsd.iota16(indexBufDsd);
    @map(calc_fitness, indexBufDsd, fitBufDsd);
}

fn sample_tournament_winner() u16 {
    var bestFit: f16 = math.NEGATIVE_INF(f16);
    var bestIdx: u16 = 0;
    for (@range(i16, tournamentSize)) |i| {
        const idx = opscalar.unif16(popSize);
        const fit = fitBuf[idx];
        if (fit > bestFit) {
            bestFit = fit;
            bestIdx = idx;
        }
    }
    return bestIdx;
}

fn do_selection() void {
    eval_fitnesses();
    @map(sample_tournament_winner, indexBufDsd);

    @mov32(swapDsd, bufferDsd);

    @mov32(bufferDsd, 0);
    for (@range(i16, genomeWords)) |w| {
        const wordDsd = @increment_dsd_offset(genomeDsd, w, u32);
        @add16(wordDsd, indexBufDsd, w);
    }
    @map(get_swap_word, indexBufDsd, bufferDsd);
}

fn do_generation() void {
    do_selection();
    opdsd.iota16(indexBufDsd);
    @map(do_mutation, indexBufDsd);
}

fn get_genome(i: u16) [*]u32 {
    return @ptrcast([*]u32, &buffer[i * genomeWords]);
}

fn get_population_word(i: u16) u32 { return buffer[i]; }

fn get_swap_word(i: u16) u32 { return swap[i]; }

fn put_population_word(data: u32, loc: u16) void { buffer[loc] = data; }

fn immigrate_genomes(fromDsd: mem1d_dsd, nGenomes: u16) void {
    sample_n(nGenomes);
    const swapDsd_ = @set_dsd_length(swapDsd, sampleWords);
    @map(put_population_word, fromDsd, swapDsd_);
}

fn emigrate_genomes(toDsd: mem1d_dsd, nGenomes: u16) void {
    sample_n(nGenomes);
    const nWords = nGenomes * genomeWords;
    const swapDsd_ = @set_dsd_length(swapDsd, nWords);
    @map(get_population_word, swapDsd_, toDsd);
}

// implement directly to save DSRs
fn _mul_genome_words(i: u16) u16 { return i * genomeWords; }

fn sample_n(n: u16) void {
    // sample n genome indices
    const popIndexDsd = @set_dsd_length(indexBufDsd, n);
    const nDsd = dsd.get_dsd_repeat16(n);
    @map(opscalar.unif16, nDsd, popIndexDsd);

    // convert to word indices
    // const genomeWordsDsd = dsd.get_dsd_repeat16(genomeWords);
    @map(_mul_genome_words, popIndexDsd, popIndexDsd);

    // set swap buffer to within-genome offsets
    const sampleWords = n * genomeWords;
    const swapDsd_ = @set_dsd_length(swapDsd, sampleWords);

    // add sampled word indices to word offsets
    @mov32(swapDsd_, 0);
    for (@range(i16, genomeWords)) |w| {
        const wordDsd = @set_dsd_length(
            @increment_dsd_offset(genomeDsd, w, u32),
            n,
        );
        @add16(wordDsd, indexBufDsd, w);
    }
}

fn do_swap() void { @mov32(swapDsd, bufferDsd); }  // deprecated
